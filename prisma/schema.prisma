generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // <- tem que estar exatamente assim
}

enum Role {
  ADMIN
  CUSTOMER
}

model User {
  id                 String               @id @default(cuid())
  email              String               @unique
  password           String
  name               String?
  role               Role                 @default(ADMIN)
  isActive           Boolean              @default(true)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  PasswordResetToken PasswordResetToken[]
}

enum TxType {
  CREDIT
  DEBIT
}

model Customer {
  id                      String    @id @default(uuid())
  // Você pode preencher/relacionar dinamicamente por CPF/CNPJ (taxNumber) quando fizer o match:
  name                    String?
  taxNumber               String?   @unique // CPF/CNPJ sem máscara (opcional)
  email                   String?
  deposits                Deposit[]
  payments                Payment[]
  externalAccountHolderId String?   @unique // ID do correntista na BRX
  refunds                 Refund[]
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  Wallet                  Wallet[]
}

model Refund {
  id          String    @id @default(uuid())
  endToEnd    String    @unique
  // Demais campos a partir do endpoint "Consulta de Devolução" (não fornecidos na amostra).
  status      String?
  statusId    Int?
  valueCents  Int?
  refundDate  DateTime?
  bankPayload Json
  customerId  String?
  customer    Customer? @relation(fields: [customerId], references: [id])
  createdAt   DateTime  @default(now())

  @@index([customerId])
}

model Payment {
  id                  String    @id @default(uuid())
  endToEnd            String    @unique
  identifier          String? // enviado pelo integrador quando solicita o pagamento
  paymentValue        Int // em centavos
  paymentDate         DateTime
  receiverName        String?
  receiverTaxNumber   String?
  receiverBankCode    String?
  receiverBankBranch  String?
  receiverBankAccount String?
  receiverISPB        String?
  receiverPixKey      String?
  payerName           String?
  payerTaxNumber      String?
  payerBankCode       String?
  payerBankBranch     String?
  payerBankAccount    String?
  payerISPB           String?
  status              String?
  statusId            Int?
  errorMessage        String?
  bankPayload         Json
  customerId          String?
  customer            Customer? @relation(fields: [customerId], references: [id])
  createdAt           DateTime  @default(now())

  @@index([customerId])
}

model Deposit {
  id                       String    @id @default(uuid())
  endToEnd                 String    @unique
  accountHolderId          String? // Accou(n)tHolderId (aceitamos ambos nos webhooks)
  receiptValue             Int // em centavos (BRL)
  receiptDate              DateTime
  payerName                String?
  payerTaxNumber           String? // CPF/CNPJ do pagador
  payerBankCode            String?
  payerBankBranch          String?
  payerBankAccount         String?
  payerBankAccountDigit    String?
  payerISPB                String?
  payerMessage             String?
  receiverName             String?
  receiverTaxNumber        String?
  receiverBankCode         String?
  receiverBankBranch       String?
  receiverBankAccount      String?
  receiverBankAccountDigit String?
  receiverISPB             String?
  receiverPixKey           String?
  status                   String? // "confirmed", etc.
  statusId                 Int?
  bankPayload              Json // payload bruto como veio
  customerId               String?
  customer                 Customer? @relation(fields: [customerId], references: [id])
  createdAt                DateTime  @default(now())

  @@index([customerId])
}

model Wallet {
  id         String   @id @default(cuid())
  customerId String
  currency   String // "BRL"
  balance    Decimal  @db.Decimal(18, 2)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  customer    Customer      @relation(fields: [customerId], references: [id])
  Transaction Transaction[]
  Payout      Payout[]

  @@unique([customerId, currency])
}

model Transaction {
  id        String   @id @default(cuid())
  walletId  String
  type      TxType
  amount    Decimal  @db.Decimal(18, 2)
  reference String   @unique // usamos EndToEnd como idempotência
  metadata  Json?
  createdAt DateTime @default(now())

  wallet Wallet   @relation(fields: [walletId], references: [id])
  Payout Payout[]

  @@index([walletId, createdAt])
}

model PixWebhookEvent {
  id          String    @id @default(cuid())
  provider    String // "mtbank"
  eventType   String // "cash-in"
  signature   String?
  endToEndId  String?
  raw         Json
  receivedAt  DateTime  @default(now())
  processedAt DateTime?
  error       String?
  // opcionalmente: @@unique([provider, endToEndId])
}

enum PayoutStatus {
  PENDING
  PROCESSING
  CONFIRMED
  FAILED
  CANCELED
}

model Payout {
  id           String       @id @default(cuid())
  walletId     String
  amount       Decimal      @db.Decimal(18, 2)
  status       PayoutStatus @default(PENDING)
  requestId    String       @unique // idempotência da requisição do seu sistema
  endToEndId   String?      @unique // quando o banco retornar
  bankRequest  Json? // request enviado ao banco
  bankResponse Json? // resposta imediata
  error        String?

  // Beneficiário (quem recebe)
  beneficiaryName      String
  beneficiaryTaxNumber String
  pixKey               String
  pixKeyType           String // CPF/CNPJ/EMAIL/CELULAR/CHAVE_ALEATORIA
  // opcional: dados bancários se o banco exigir

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  wallet    Wallet       @relation(fields: [walletId], references: [id])
  debitTx   Transaction? @relation(fields: [debitTxId], references: [id])
  debitTxId String?

  @@index([walletId, status, createdAt])
}

model WebhookEvent {
  id          String   @id @default(uuid())
  kind        String // 'cash-in' | 'cash-out' | 'refunds'
  endToEnd    String?
  receivedAt  DateTime @default(now())
  rawBody     Json
  headers     Json
  ip          String?
  signatureOk Boolean? // caso a BRX passe a assinar; por ora, null

  @@index([kind])
  @@index([endToEnd])
}

// prisma/schema.prisma
model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String // hash do token (nunca salve o token puro)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([tokenHash])
}
